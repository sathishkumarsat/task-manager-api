const mongoose = require('mongoose');
const validator = require('validator');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Task = require('./task');

const userSchema = mongoose.Schema({    //creating Schema
    name: {
        type: String,
        required: true,
        trim: true
    },

    email: {
        type: String,
        unique: true,
        trim: true,
        required: true,
        lowercase: true,
        validate(value) {
            if (!validator.isEmail(value)) {   //!('isEmail' returns 'false' - if not valid ) = 'true'
                throw new Error('Email is not valid');
            }
        }
    },

    age: {
        type: Number,
        default: 0,
        validate(value) {
            if (value < 0) {
                throw new Error('Age must be a positive number');
            }
        }
    },

    password: {
        type: String,
        required: true,
        trim: true,
        minlength: 6,
        validate(value) {
            if (value.toLowerCase().includes('password')) { //convert to lowercase(if 'Password')
                throw new Error('Password must not contain "password"');
            }
        }
    },

    tokens: [{//It is array of token objects, bcz every time we generate a new token, to store array is needed
        token: {//no other validators like trim,.. are not required bcz it will be generated by server only
            type: String,
            required: true
        }
    }],
    avatar: {//keep it optional n validated in route
        type: Buffer //binary image data
    }
}, {
    timestamps: true
});


//To get all tasks by user
userSchema.virtual('tasks', {
    ref: 'Task',//have reference on the virtual field tasks on Task model
    localField: '_id',//user id
    foreignField: 'owner'//also user id
})


//Generating JWT token function
userSchema.methods.generateAuthToken = async function () {  //not arrow fn, methods are accessible on the instances - instance methods

    const user = this;

    const token = jwt.sign({ _id: user._id.toString() }, process.env.JWT_SECRET);
    //1arg - in obj id should be unique & string(jwt expects), 2arg - random secret string
    // user._id.toString()

    user.tokens = user.tokens.concat({ token });//({token: token}) - asigning generated token to the user model
    await user.save();//To save to the DB

    return token;
}


//Adding findByCredentials to userSchema statics
userSchema.statics.findByCredentials = async (email, password) => { //static methods are accessible on the model - model methods
    const user = await User.findOne({ email });//({emial}) same as ({email:email})

    if (!user) {//if user not found
        throw new Error('Unable to login!');
    }

    const isMatch = await bcrypt.compare(password, user.password);//check credentials if user found

    if (!isMatch) {
        throw new Error('Unable to login!');//Error message for all wrong logins better be same(not specific like wrong pwd/email)
        //bcz it will expose more info, advantageous to hackers
    }

    return user;//returns user if credentials are correct
}


//Using middleware - to hash password
userSchema.pre('save', async function (next) {  //needs to be standard fn to bind, not arrow fn
    //this -> gives access to individual user about to save or we can use below instead of 'this' directly
    const user = this;
    //console.log('Just before saving');

    if (user.isModified('password')) {   //To check password is hashed or not before hashing, password - field name
        //if() returns true for new user & password change
        user.password = await bcrypt.hash(user.password, 8);    //overriding plain text value by saving same variable
    }

    next(); //closing fn doesn't count for asynchronous fns, so next as arg&method tells fn is completed, 
    //or else it's gonna hang forever without saving user
});


//Delete user taks when user removed
userSchema.pre('remove', async function (next) {
    const user = this;

    //to delete all tasks wher owner = user id
    await Task.deleteMany({ owner: user._id });

    next();
});

//Hiding Private Data
userSchema.methods.toJSON = function () {
    const user = this;
    const userObject = user.toObject();//toObject() method is provided by mongoose, gives raw profile data

    delete userObject.password;
    delete userObject.tokens;
    delete userObject.avatar;//bcz of large binary data

    return userObject;
}


//Creating model
const User = mongoose.model('User', userSchema);    //creating Model

module.exports = User;






